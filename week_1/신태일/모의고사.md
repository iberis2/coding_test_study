## 🧩 문제 설명

- [모의고사](https://school.programmers.co.kr/learn/courses/30/lessons/42840)

### 💡 풀이 과정 (Algorithm)

1. **수포자들의 찍기 패턴이 일정하니까 배열로 만들어야겠다.**
   - 1번(5개), 2번(8개), 3번(10개) 단위로 반복되는 패턴을 각각 `a, b, c` 배열에 저장한다.
2. **문제 수가 패턴보다 많을 수 있으니 나머지에만 초점을 맞춰야 겠다.**
   - `answers`를 순회하면서 현재 인덱스를 패턴의 길이로 나눈 나머지(`i % pattern.length`)를 활용해 정답 여부를 체크한다.
3. **맞힌 개수들을 비교해서 가장 큰 점수를 찾고, 그 점수를 가진 사람만 결과 배열에 넣어야겠다.**
   - `Math.max`로 최고 점수를 뽑아내고, 다시 `cnt` 배열 돌려서 최고 점수와 일치하는 인덱스를 결과 리스트에 담는다. 루프를 순서대로 돌면 자동으로 오름차순이 된다.

### 💻 코드 (Code)

```javascript
function solution(answers) {
  const a = [1, 2, 3, 4, 5];
  const b = [2, 1, 2, 3, 2, 4, 2, 5];
  const c = [3, 3, 1, 1, 2, 2, 4, 4, 5, 5];

  let cnt = [0, 0, 0];

  for (let i = 0; i < answers.length; i++) {
    if (a[i % a.length] === answers[i]) cnt[0]++;
    if (b[i % b.length] === answers[i]) cnt[1]++;
    if (c[i % c.length] === answers[i]) cnt[2]++;
  }

  const maxNum = Math.max(...cnt);

  const result = [];
  for (let i = 0; i < cnt.length; i++) {
    if (cnt[i] === maxNum) {
      result.push(i + 1);
    }
  }

  return result;
}
```

### 🏁 회고 (Retrospective)

- 문제 수가 최대 10,000개이므로 O(n)의 시간 복잡도로 충분히 해결 가능
